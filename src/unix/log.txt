--- coreaudio#.c	Sun Jul  6 02:55:09 2003
+++ coreaudio.c	Tue Apr  5 01:50:15 2005
@@ -10,6 +10,7 @@
  *
  * -bat. 12/04/2001 
  */     
+/* modified for PC-6001 emulator iP6 by Koichi Nishida 2004/5/24 */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -21,9 +22,13 @@
 #include "sysdep/sysdep_dsp.h"
 #include "sysdep/sysdep_dsp_priv.h"
 #include "sysdep/plugin_manager.h"
+#include "../P6.h"
 
 #define NAME_LEN 256		/* max length of a device name */
 
+#define QUEUE_LIMIT 64
+int element_number = 0;
+
 /*
  * We have to implement a FIFO of blocks of floats, without using up
  * vast amounts of memory, or being too inefficient. We thus require
@@ -54,17 +59,18 @@
 unsafe_queue_audio_block(struct audio_queue *queue, float *block, int len)
 {
 	struct audio_block *new = malloc(sizeof(struct audio_block));
-
 	/* if malloc fails we ditch the block */
-	if(!new)
-		return;
-
+	if(!new) {
+		return; 
+	}
 	/* fill it out */
 	new->block_base = block;
 	new->current_base = block;
 	new->samples_left = len;
 	new->next = NULL;
 
+	element_number++;
+
 	/* add it to the end */
 	if(!queue->head) {
 		queue->head = new;
@@ -104,7 +110,6 @@
 	/* anything to do ? */
 	if(len < 1)
 		return;
-
 	/* zero padding ? */
 	if(!head) {
 		int i;
@@ -112,7 +117,6 @@
 			*block++ = 0.0;
 		return;
 	}
-
 	/* smaller than current */
 	if(len < head->samples_left) {
 		memcpy(block, head->current_base, len*sizeof(float));
@@ -132,6 +136,9 @@
 		queue->tail = NULL;
 	free(head->block_base);
 	free(head);
+
+	element_number--;
+
 	unsafe_dequeue_audio_block(queue, block, len);
 }
 
@@ -177,11 +184,12 @@
 {
 	int i;
 	struct coreaudio_private *priv = (struct coreaudio_private*)data;
-	for(i=0;i<out_data->mNumberBuffers;i++)
+	for(i=0;i<out_data->mNumberBuffers;i++) {
 		dequeue_audio_block(&(priv->queue),
 				out_data->mBuffers[i].mData,
 				out_data->mBuffers[i].mDataByteSize /
 				 sizeof(float));
+	}
 	return noErr;
 }
 
@@ -191,7 +199,7 @@
  * entriely trust OS X not to make a final call to the callback.
  */
 
-static void
+void
 coreaudio_dsp_destroy(struct sysdep_dsp_struct *dsp)
 {
 	struct coreaudio_private *priv = (struct coreaudio_private*)dsp->_priv;
@@ -200,13 +208,13 @@
 	/* stop the device */
         audio_err = AudioDeviceStop(priv->device, coreaudio_dsp_play);
         if(audio_err != noErr)
-		fprintf(stderr,"error %ld stopping audio device\n",
+		if (Verbose) printf("error %ld stopping audio device\n",
 				audio_err);
 
 	/* remove the callback function */
         audio_err = AudioDeviceRemoveIOProc(priv->device, coreaudio_dsp_play);
         if(audio_err != noErr)
-		fprintf(stderr,"error %ld removing callback function\n",
+		if (Verbose) printf("error %ld removing callback function\n",
 				audio_err);
 }
 
@@ -219,7 +227,7 @@
  * rate has to be an integral multiple higher that that generated by xmame.
  */
    
-static int
+int
 coreaudio_dsp_write(struct sysdep_dsp_struct *dsp,
 		unsigned char *data, int count)
 {
@@ -228,43 +236,43 @@
 	int fake_mono = priv->fake_mono;
 	int mult = priv->rate_mult;
 	float *data_block, *data_ptr;
-	short *short_ptr;
+        unsigned char *char_ptr;   // KN 2004/5/20
 	int i;
-
+	
 	/* make the data block - always stereo */
 	data_block = malloc(count * 2 * sizeof(float) * mult);
 	if(!data_block) {
-		fprintf(stderr, "out of memory queueing audio block");
+		if (Verbose) printf("out of memory queueing audio block");
 		return count;
 	}
-
 	/*
 	 * copy in the data, each sample is added twice if we are running
 	 * a half rate emulation. If we are in mono mode then the second sample
 	 * is the same as the first and not taken from the buffer at all
 	 */
 	data_ptr = data_block;
-	short_ptr = (short*)data;
-	for(i=0;i<count;i++) {
+	char_ptr = (unsigned char*)data;                                     // KN 2004/5/20
+	for(i=0;i<count;i++) { 
 		float left_chan, right_chan;
 		int m;
-
 		/* setup the left and right values */
-		left_chan = *short_ptr++ / 32768.0;
+                left_chan = ((*(char_ptr++))-128.0) / 256.0;             // KN 2004/5/20
+
 		if(is_stereo)
-			right_chan = *short_ptr++ / 32768.0;
+                      right_chan = ((*(char_ptr++))-128.0) / 256.0;    // KN 2004/5/20
 		else
 			right_chan = left_chan;
 
 		/* add the sammples */
 		for(m=0;m<mult;m++) {
-			*data_ptr++ = left_chan;
+			*(data_ptr++) = left_chan;
 			if(fake_mono)
 				*data_ptr++ = right_chan;
 		}
-	}
 
+	}
 	/* and queue it */
+	while (element_number >= QUEUE_LIMIT) {};
 	queue_audio_block(&(priv->queue), data_block, count * 2 * mult);
 	return count;
 }
@@ -277,14 +285,14 @@
  * revert to the emulations if things do not work out.
  */
 
-static void*
+void*
 coreaudio_dsp_create(const void *flags)
 {
 	const struct sysdep_dsp_create_params *params = flags;
 	struct sysdep_dsp_struct *dsp = NULL;
 	struct coreaudio_private *priv = NULL;
 	OSStatus audio_err;
-	UInt32 audio_count, audio_buff_len;
+	UInt32 audio_count /* , audio_buff_len */;
 	char audio_device[NAME_LEN];
 	AudioStreamBasicDescription default_format, new_format;
 
@@ -295,18 +303,17 @@
 		return NULL;
 	}
 
-	/* always 16 bit samples */
-	dsp->hw_info.type |= SYSDEP_DSP_16BIT;
-	fprintf(stderr, "info: requesting %s sound at %d hz\n",
-			(params->type & SYSDEP_DSP_STEREO) ?
-			"stereo" : "mono", params->samplerate);
+	/* always 8 bit samples */
+//	dsp->hw_info.type |= SYSDEP_DSP_8BIT;
+	if (Verbose) printf("info: requesting %s sound at %d hz\n",
+		(params->type & SYSDEP_DSP_STEREO) ?
+		"stereo" : "mono", params->samplerate);
 
 	/* make the private structure */
 	if (!(priv = calloc(1, sizeof(struct coreaudio_private)))) {
 		perror("malloc failed for struct coreaudio_private\n");
 		return NULL;
 	}
-
 	/* set up with queue, no device, and zero length buffer */
  	priv->device = kAudioDeviceUnknown;
 	priv->queue.head = NULL;
@@ -315,14 +322,15 @@
 		perror("failed to create mutex\n");
 		return NULL;
 	}
-
 	/* get the default device */
 	audio_count = sizeof(AudioDeviceID);
 	audio_err = AudioHardwareGetProperty(
 			kAudioHardwarePropertyDefaultOutputDevice,
 			&audio_count, &(priv->device));
+	fflush(stdout);		
 	if(audio_err != noErr) {
-		fprintf(stderr,"error %ld getting default audio device\n",
+
+		if (Verbose) printf("error %ld getting default audio device\n",
 				audio_err);
 		return NULL;
 	}
@@ -333,24 +341,22 @@
 			kAudioDevicePropertyDeviceName,
 			&audio_count, audio_device);
 	if(audio_err != noErr) {
-		fprintf(stderr,"error %ld getting default device name\n",
+		if (Verbose) printf("error %ld getting default device name\n",
 				audio_err);
 		return NULL;
 	}
 	audio_device[NAME_LEN-1] = '\0';	/* just in case */
-	fprintf(stderr, "info: sound device is %s\n", audio_device);
-
+	if (Verbose) printf("info: sound device is %s\n", audio_device);
 	/* get the default parameters */
 	audio_count = sizeof(AudioStreamBasicDescription);
 	audio_err = AudioDeviceGetProperty(priv->device, 0, false,
 			kAudioDevicePropertyStreamFormat,
 			&audio_count, &default_format);
 	if(audio_err != noErr) {
-		fprintf(stderr,"error %ld getting basic device parameters\n",
+		if (Verbose) printf("error %ld getting basic device parameters\n",
 				audio_err);
 		return NULL;
 	}
-
 	/* try and set the parameters */
 	new_format = default_format;
 	new_format.mChannelsPerFrame = (params->type & SYSDEP_DSP_STEREO)
@@ -370,14 +376,14 @@
 			kAudioDevicePropertyStreamFormat,
 			&audio_count, &new_format);
 	if(audio_err != noErr) {
-		fprintf(stderr,"error %ld getting basic device parameters\n",
+		if (Verbose) printf("error %ld getting basic device parameters\n",
 				audio_err);
 		return NULL;
 	}
 
 	/* the device must do linear pcm */
 	if(new_format.mFormatID != kAudioFormatLinearPCM) {
-		fprintf(stderr,"device does not do linear pcm!\n");
+		if (Verbose) printf("device does not do linear pcm!\n");
 		return NULL;
 	}
 
@@ -386,21 +392,21 @@
 	if(params->type & SYSDEP_DSP_STEREO) {
 		dsp->hw_info.type |= SYSDEP_DSP_STEREO;
 		if(new_format.mChannelsPerFrame != 2) {
-			fprintf(stderr,"device does not do stereo!\n");
+			if (Verbose) printf("device does not do stereo!\n");
 			return NULL;
 		} else
-			fprintf(stderr, "info: sound device native stereo\n");
+			if (Verbose) printf("info: sound device native stereo\n");
 	} else  {
 		if(new_format.mChannelsPerFrame != 1) {
 			if(new_format.mChannelsPerFrame != 2) {
-				fprintf(stderr,"device does %ld channels!\n",
+				if (Verbose) printf("device does %ld channels!\n",
 						new_format.mChannelsPerFrame);
 				return NULL;
 			}
-			fprintf(stderr, "info: emulating mono onto stereo\n");
+			if (Verbose) printf("info: emulating mono onto stereo\n");
 			priv->fake_mono = 1;
 		} else
-			fprintf(stderr, "info: sound device native mono\n");
+			if (Verbose) printf("info: sound device native mono\n");
 	}
 
 	/* create and check the channel multiplier */
@@ -408,12 +414,12 @@
 			params->samplerate;
 	if(((int)(new_format.mSampleRate+0.5)) !=
 			(params->samplerate*priv->rate_mult)) {
-		fprintf(stderr,"rate %f is not a multiple of %d\n",
+		if (Verbose) printf("rate %f is not a multiple of %d\n",
 				new_format.mSampleRate, params->samplerate);
 		return NULL;
 	}
 	if(priv->rate_mult != 1)
-		fprintf(stderr, "info: mutiplying %d hz by %d to give %d hz\n",
+		if (Verbose) printf("info: mutiplying %d hz by %d to give %d hz\n",
 				params->samplerate, priv->rate_mult,
 				(int)(new_format.mSampleRate+0.5));
 
@@ -421,7 +427,7 @@
         audio_err = AudioDeviceAddIOProc(priv->device,
 			coreaudio_dsp_play, (void*)priv);
 	if(audio_err != noErr) {
-		fprintf(stderr,"error %ld adding callback function\n",
+		if (Verbose) printf("error %ld adding callback function\n",
 				audio_err);
 		return NULL;
 	}
@@ -429,7 +435,7 @@
 	/* start it playing */
         audio_err = AudioDeviceStart(priv->device, coreaudio_dsp_play);
 	if(audio_err != noErr) {
-		fprintf(stderr,"error %ld starting audio device\n",
+		if (Verbose) printf("error %ld starting audio device\n",
 				audio_err);
 		return NULL;
 	}
@@ -447,7 +453,6 @@
 /*
  * The public variables structure
  */
-
 const struct plugin_struct sysdep_dsp_coreaudio = {
 	"coreaudio",
 	"sysdep_dsp",
