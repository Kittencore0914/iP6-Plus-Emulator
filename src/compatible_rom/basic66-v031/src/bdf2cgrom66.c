/*
  bdf2cgrom66.c  2019.9.17 version
    convert .bdf font file to CGROM60.66/CGROM66.66 format for PC-6601
    by AKIKAWA, Hisashi
    This software is redistributable under the LGPLv2.1 or any later version.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NCHR 256
#define BDFSIZE 64
#define SIZEX 8
#define SIZEY_60 12
#define SIZEY_66 10

enum {JIS, UNI};

void cnv(FILE *fp, int ascii, const int **tbl, const int **altsuit, const int **mix1, const int **mix2, int size_x_out, int size_y_out, unsigned char bmp60[][16]);
int getbdfpar(FILE *fp, int ascii, int *pixel_x, int *ascent, int *descent);
int isnodata(unsigned char *bmp60);

int main(int argc, char *argv[])
{
  int i, j;
  int opt;
  int ascii = 0;
  char outfile[FILENAME_MAX + 1];
  unsigned char bmp60[NCHR * 2][16];
  FILE *fp1, *fp2, *fpout;

  const int jistbl[] = {
    0x2121, 0x376e, 0x3250, 0x3f65, 0x4c5a, 0x3662, 0x455a, 0x467c, /* 00 */
    0x472f, 0x315f, 0x3b7e, 0x4a2c, 0x4943, 0x4934, 0x4069, 0x4b7c,
    0x2650, 0x2835, 0x2833, 0x2834, 0x2832, 0x2836, 0x282d, 0x282c, /* 10 */
    0x282e, 0x282f, 0x2831, 0x2830, 0x215f, 0x4267, 0x4366, 0x3e2e,
    0x2121, 0x212a, 0x2149, 0x2174, 0x2170, 0x2173, 0x2175, 0x2147, /* 20 */
    0x214a, 0x214b, 0x2176, 0x215c, 0x2124, 0x215d, 0x2125, 0x213f,
    0x2330, 0x2331, 0x2332, 0x2333, 0x2334, 0x2335, 0x2336, 0x2337, /* 30 */
    0x2338, 0x2339, 0x2127, 0x2128, 0x2163, 0x2161, 0x2164, 0x2129,
    0x2177, 0x2341, 0x2342, 0x2343, 0x2344, 0x2345, 0x2346, 0x2347, /* 40 */
    0x2348, 0x2349, 0x234a, 0x234b, 0x234c, 0x234d, 0x234e, 0x234f,
    0x2350, 0x2351, 0x2352, 0x2353, 0x2354, 0x2355, 0x2356, 0x2357, /* 50 */
    0x2358, 0x2359, 0x235a, 0x214c, 0x216f, 0x214d, 0x2130, 0x2132,
    0x2121, 0x2361, 0x2362, 0x2363, 0x2364, 0x2365, 0x2366, 0x2367, /* 60 */
    0x2368, 0x2369, 0x236a, 0x236b, 0x236c, 0x236d, 0x236e, 0x236f,
    0x2370, 0x2371, 0x2372, 0x2373, 0x2374, 0x2375, 0x2376, 0x2377, /* 70 */
    0x2378, 0x2379, 0x237a, 0x2150, 0x2143, 0x2151, 0x2141, 0x2121,
    0x263a, 0x263e, 0x2640, 0x263c, 0x217b, 0x217c, 0x2472, 0x2421, /* 80 */
    0x2423, 0x2425, 0x2427, 0x2429, 0x2463, 0x2465, 0x2467, 0x2443,
    0x2121, 0x2422, 0x2424, 0x2426, 0x2428, 0x242a, 0x242b, 0x242d, /* 90 */
    0x242f, 0x2431, 0x2433, 0x2435, 0x2437, 0x2439, 0x243b, 0x243d,
    0x2121, 0x2123, 0x2156, 0x2157, 0x2122, 0x2126, 0x2572, 0x2521, /* a0 */
    0x2523, 0x2525, 0x2527, 0x2529, 0x2563, 0x2565, 0x2567, 0x2543,
    0x213c, 0x2522, 0x2524, 0x2526, 0x2528, 0x252a, 0x252b, 0x252d, /* b0 */
    0x252f, 0x2531, 0x2533, 0x2535, 0x2537, 0x2539, 0x253b, 0x253d,
    0x253f, 0x2541, 0x2544, 0x2546, 0x2548, 0x254a, 0x254b, 0x254c, /* c0 */
    0x254d, 0x254e, 0x254f, 0x2552, 0x2555, 0x2558, 0x255b, 0x255e,
    0x255f, 0x2560, 0x2561, 0x2562, 0x2564, 0x2566, 0x2568, 0x2569, /* d0 */
    0x256a, 0x256b, 0x256c, 0x256d, 0x256f, 0x2573, 0x212b, 0x212c,
    0x243f, 0x2441, 0x2444, 0x2446, 0x2448, 0x244a, 0x244b, 0x244c, /* e0 */
    0x244d, 0x244e, 0x244f, 0x2452, 0x2455, 0x2458, 0x245b, 0x245e,
    0x245f, 0x2460, 0x2461, 0x2462, 0x2464, 0x2466, 0x2468, 0x2469, /* f0 */
    0x246a, 0x246b, 0x246c, 0x246d, 0x246f, 0x2473, 0x2121, 0x2121
  };
  const int unitbl[] = {
    0x3000, 0x6708, 0x706b, 0x6c34, 0x6728, 0x91d1, 0x571f, 0x65e5, /* 00 */
    0x5e74, 0x5186, 0x6642, 0x5206, 0x79d2, 0x767e, 0x5343, 0x4e07,
    0x03c0, 0x253b, 0x2533, 0x252b, 0x2523, 0x254b, 0x2503, 0x2501, /* 10 */
    0x250f, 0x2513, 0x2517, 0x251b, 0x00d7, 0x5927, 0x4e2d, 0x5c0f,
    0x3000, 0xff01, 0x201d, 0xff03, 0xff04, 0xff05, 0xff06, 0x2019, /* 20 */
    0xff08, 0xff09, 0xff0a, 0xff0b, 0xff0c, 0xff0d, 0xff0e, 0xff0f,
    0xff10, 0xff11, 0xff12, 0xff13, 0xff14, 0xff15, 0xff16, 0xff17, /* 30 */
    0xff18, 0xff19, 0xff1a, 0xff1b, 0xff1c, 0xff1d, 0xff1e, 0xff1f,
    0xff20, 0xff21, 0xff22, 0xff23, 0xff24, 0xff25, 0xff26, 0xff27, /* 40 */
    0xff28, 0xff29, 0xff2a, 0xff2b, 0xff2c, 0xff2d, 0xff2e, 0xff2f,
    0xff30, 0xff31, 0xff32, 0xff33, 0xff34, 0xff35, 0xff36, 0xff37, /* 50 */
    0xff38, 0xff39, 0xff3a, 0x3014, 0xffe5, 0x3015, 0xff3e, 0xff3f,
    0x3000, 0xff41, 0xff42, 0xff43, 0xff44, 0xff45, 0xff46, 0xff47, /* 60 */
    0xff48, 0xff49, 0xff4a, 0xff4b, 0xff4c, 0xff4d, 0xff4e, 0xff4f,
    0xff50, 0xff51, 0xff52, 0xff53, 0xff54, 0xff55, 0xff56, 0xff57, /* 70 */
    0xff58, 0xff59, 0xff5a, 0xff5b, 0xff5c, 0xff5d, 0x301c, 0x3000,
    0x2660, 0x2665, 0x2663, 0x2666, 0x25cb, 0x25cf, 0x3092, 0x3041, /* 80 */
    0x3043, 0x3045, 0x3047, 0x3049, 0x3083, 0x3085, 0x3087, 0x3063,
    0x3000, 0x3042, 0x3044, 0x3046, 0x3048, 0x304a, 0x304b, 0x304d, /* 90 */
    0x304f, 0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 0x305b, 0x305d,
    0x3000, 0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1, /* a0 */
    0x30a3, 0x30a5, 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7, 0x30c3,
    0x30fc, 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad, /* b0 */
    0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7, 0x30b9, 0x30bb, 0x30bd,
    0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8, 0x30ca, 0x30cb, 0x30cc, /* c0 */
    0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5, 0x30d8, 0x30db, 0x30de,
    0x30df, 0x30e0, 0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8, 0x30e9, /* d0 */
    0x30ea, 0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x309b, 0x309c,
    0x305f, 0x3061, 0x3064, 0x3066, 0x3068, 0x306a, 0x306b, 0x306c, /* e0 */
    0x306d, 0x306e, 0x306f, 0x3072, 0x3075, 0x3078, 0x307b, 0x307e,
    0x307f, 0x3080, 0x3081, 0x3082, 0x3084, 0x3086, 0x3088, 0x3089, /* f0 */
    0x308a, 0x308b, 0x308c, 0x308d, 0x308f, 0x3093, 0x3000, 0x3000
  };

  const int jisaltsuit[] = {0x2225, 0x2227, 0x217a, 0x2221};
  const int unialtsuit[] = {0x25b2, 0x25bc, 0x2605, 0x25c6};

  const int jistbl_semi[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 00 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 10 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 20 */
    0x222a, 0x222b, 0x222c, 0x222d, 0x2325, 0x2328, 0x2327, 0x2326,
    0x2330, 0x2331, 0x2332, 0x2333, 0x2334, 0x2335, 0x2336, 0x2337, /* 30 */
    0x2338, 0x2339, 0x0000, 0x0000, 0x0000, 0x2167, 0x2267, 0x2262,
    0x2958, 0x2964, 0x2970, 0x2960, 0x295e, 0x295f, 0x2b2a, 0x295a, /* 40 */
    0x2971, 0x296c, 0x2622, 0x2624, 0x262b, 0x2632, 0x2635, 0x2638,
    0x2641, 0x2642, 0x2643, 0x2644, 0x2645, 0x2648, 0x264b, 0x264c, /* 50 */
    0x264d, 0x2651, 0x2652, 0x2654, 0x2655, 0x2658, 0x0000, 0x225f,
    0x2361, 0x2b37, 0x2b30, 0x295c, 0x2b43, 0x2b38, 0x0000, 0x0000, /* 60 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2359, 0x2349,
    0x2a79, 0x2a69, 0x2a68, 0x2966, 0x2a76, 0x2a7c, 0x295d, 0x0000, /* 70 */
    0x0000, 0x2b34, 0x2b3c, 0x2b35, 0x2959, 0x0000, 0x0000, 0x0000,
    0x215f, 0x2160, 0x215e, 0x235b, 0x2166, 0x2162, 0x2165, 0x0000, /* 80 */
    0x0000, 0x0000, 0x0000, 0x2265, 0x2241, 0x2240, 0x2168, 0x2268,
    0x0000, 0x0000, 0x2224, 0x2225, 0x217a, 0x0000, 0x0000, 0x0000, /* 90 */
    0x0000, 0x0000, 0x2667, 0x0000, 0x2228, 0x0000, 0x2178, 0x0000,
    0x2169, 0x216a, 0x317a, 0x464c, 0x233a, 0x217d, 0x0000, 0x233b, /* a0 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x2251, 0x2252, 0x2253, 0x0000,
    0x0000, 0x5244, 0x0000, 0x0000, 0x0000, 0x0000, 0x217e, 0x4a38, /* b0 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x217c, 0x217c, 0x2223, 0x2142, 0x2154, 0x215f, 0x2131, 0x2152, /* c0 */
    0x2131, 0x2140, 0x2132, 0x2132, 0x2161, 0x217c, 0x2142, 0x2142,
    0x217c, 0x217c, 0x2223, 0x2142, 0x215f, 0x2154, 0x2154, 0x213f, /* d0 */
    0x2131, 0x2132, 0x213f, 0x2140, 0x2161, 0x2142, 0x217c, 0x2142,
    0x217c, 0x217c, 0x2223, 0x2142, 0x215f, 0x2155, 0x2155, 0x2140, /* e0 */
    0x2131, 0x2132, 0x2140, 0x213f, 0x2161, 0x2142, 0x2142, 0x2142,
    0x217c, 0x217c, 0x2223, 0x224b, 0x2155, 0x215f, 0x2131, 0x2153, /* f0 */
    0x2131, 0x213f, 0x2132, 0x2132, 0x2161, 0x217c, 0x217c, 0x2223,
  };
  const int unitbl_semi[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 00 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 10 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 20 */
    0x2192, 0x2190, 0x2191, 0x2193, 0x2197, 0x2199, 0x2196, 0x2198,
    0xff10, 0xff11, 0xff12, 0xff13, 0xff14, 0xff15, 0xff16, 0xff17, /* 30 */
    0xff18, 0xff19, 0x2491, 0x2492, 0x2493, 0x221e, 0x221d, 0x2252,
    0x00e2, 0x00ee, 0x00fb, 0x00ea, 0x00e8, 0x00e9, 0x0153, 0x00e4, /* 40 */
    0x00fc, 0x00f6, 0x0392, 0x0394, 0x039b, 0x03a3, 0x03a6, 0x03a9,
    0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b8, 0x03bb, 0x03bc, /* 50 */
    0x03bd, 0x03c1, 0x03c3, 0x03c5, 0x03c6, 0x03c9, 0x03d5, 0x2202,
    0xff41, 0x028c, 0x0259, 0x00e6, 0x025a, 0x0254, 0x0000, 0x0000, /* 60 */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x028f, 0x026a,
    0x014b, 0x0292, 0x0283, 0x00f0, 0x0272, 0x0281, 0x00e7, 0x0000, /* 70 */
    0x0000, 0x026f, 0x0265, 0x028a, 0x00e3, 0x0000, 0x0000, 0x0000,
    0x00d7, 0x00f7, 0x00b1, 0x2213, 0x2267, 0x2260, 0x2266, 0x0000, /* 80 */
    0x0000, 0x0000, 0x0000, 0x221a, 0x2229, 0x222a, 0x2234, 0x2235,
    0xfe35, 0xfe36, 0x25b3, 0x25b2, 0x2605, 0x0000, 0x25aa, 0x25a3, /* 90 */
    0x0000, 0x0000, 0x260e, 0x2733, 0x203b, 0x1d10b, 0x00a7, 0x1d10c,
    0x2642, 0x2640, 0x51f9, 0x51f8, 0x2299, 0x25ce, 0x0000, 0x0000, /* a0 */
    0x29b6, 0x0000, 0x0000, 0x229d, 0x2295, 0x2296, 0x2297, 0x2298,
    0x26e9, 0x534d, 0x26eb, 0x26e8, 0x3036, 0x26fb, 0x25c7, 0x6587, /* b0 */
    0x2b59, 0x0000, 0x0000, 0x0000, 0x26e3, 0x2693, 0x2693, 0x1f6e7,
    0x25cf, 0x25cf, 0x25a0, 0x2016, 0x300a, 0x00d7, 0x203e, 0x3008, /* c0 */
    0x203e, 0xff3c, 0xff3f, 0xff3f, 0xff1d, 0x25cf, 0x2016, 0x2016,
    0x25cf, 0x25cf, 0x25a0, 0x2016, 0x00d7, 0x300a, 0x300a, 0xff0f, /* d0 */
    0x203e, 0xff3f, 0xff0f, 0xff3c, 0xff1d, 0x2016, 0x25cf, 0x2016,
    0x25cf, 0x25cf, 0x25a0, 0x2016, 0x00d7, 0x300b, 0x300b, 0xff3c, /* e0 */
    0x203e, 0xff3f, 0xff3c, 0xff0f, 0xff1d, 0x2016, 0x2016, 0x2016,
    0x25cf, 0x25cf, 0x25a0, 0x2228, 0x300b, 0x00d7, 0x203e, 0x3009, /* f0 */
    0x203e, 0xff0f, 0xff3f, 0xff3f, 0xff1d, 0x25cf, 0x25cf, 0x25a0,
  };

  const int jistbl_mix1[] = {
    /* left-right */
    0x2361, 0x2369, 0x2375, 0x2b30, 0x2645, 0x2b43, 0x236f, 0x2379, 0x2655,
    0x2372,
    0x2331, 0x2331, 0x2331,
    0x236f, 0x2361,
    /* down-up */
    0x2361, 0x2645, 0x2b2a, 0x2b38,
    0x2361, 0x2369, 0x2375, 0x2365, 0x2365, 0x2365, 0x2361, 0x2375, 0x236f,
    0x215c,
    /* square */
    0x2222, 0x2222, 0x2222, 0x2222,
    /* circle */
    0x217b, 0x217b, 0x217b, 0x217b, 0x217b, 0x217b, 0x217b, 0x217b,
    0x217b, 0x217b, 0x217b, 0x217b, 0x217b,
    /* other */
    0x2655, 0x224a, 0x2359, 0x2349, 0x217c, 0x2223, 0x215c, 0x3b4e,
  };
  const int jistbl_mix2[] = {
    /* left-right */
    0x2127, 0x2127, 0x2127, 0x2127, 0x2127, 0x2127, 0x2127, 0x2127, 0x2127,
    0x212c,
    0x2330, 0x2331, 0x2332,
    0x2365, 0x2365,
    /* down-up */
    0x2141, 0x2141, 0x2141, 0x2141,
    0x2130, 0x2130, 0x2130, 0x2130, 0x212e, 0x212d, 0x212f, 0x212f, 0x212f,
    0x215d,
    /* square */
    0x2223, 0x2222, 0x215f, 0x2348,
    /* circle */
    0x2126, 0x2222, 0x2223, 0x2143, 0x2535, 0x215c, 0x215d, 0x215c,
    0x215d, 0x215f, 0x213f, 0x2229, 0x215f,
    /* other */
    0x2655, 0x224a, 0x2359, 0x2349, 0x217c, 0x2223, 0x215f, 0x3b4e,
  };
  const int unitbl_mix1[]= {
    /* left-right */
    0xff41, 0xff49, 0xff55, 0x0259, 0x03b5, 0x0259, 0xff5f, 0xff59, 0x03d5,
    0xff52,
    0xff11, 0xff11, 0xff11,
    0xff4f, 0xff41,
    /* down-up */
    0xff41, 0x03b5, 0x0153, 0x0254,
    0xff41, 0xff49, 0xff55, 0xff45, 0xff45, 0xff45, 0xff41, 0xff55, 0xff4f,
    0xff0b,
    /* square */
    0x25a1, 0x25a1, 0x25a1, 0x25a1,
    /* circle */
    0x25cb, 0x25cb, 0x25cb, 0x25cb, 0x25cb, 0x25cb, 0x25cb, 0x25cb,
    0x25cb, 0x25cb, 0x25cb, 0x25cb, 0x25cb,
    /* other */
    0x03c6, 0x2227, 0xff39, 0xff29,  0x25cf, 0x25a0, 0xff0b, 0x58eb,
  };
  const int unitbl_mix2[] = {
    /* left-right */
    0xff1a, 0xff1a, 0xff1a, 0xff1a, 0xff1a, 0xff1a, 0xff1a, 0xff1a, 0xff1a,
    0x2019,
    0xff10, 0xff11, 0xff12,
    0xff45, 0xff45,
    /* down-up */
    0x301c, 0x301c, 0x301c, 0x301c,
    0xff3e, 0xff3e, 0xff3e, 0xff3e, 0xff40, 0xff07, 0x00a8, 0x00a8, 0x00a8,
    0xff0d,
    /* square */
    0x25a0, 0x25a1, 0x00d7, 0xff28,
    /* circle */
    0x30fb, 0x25a1, 0x25a0, 0xff5c, 0x30b5, 0xff0b, 0xff0d, 0xff0b,
    0xff0d, 0x00d7, 0xff0f, 0x3012, 0x00d7,
    /* other */
    0x03c6, 0x2227, 0xff39, 0xff29, 0x25cf, 0x25a0, 0x00d7, 0x58eb,
  };

  const int *tbl[] = {jistbl, unitbl};
  const int *tbl_semi[] = {jistbl_semi, unitbl_semi};
  const int *altsuit[] = {jisaltsuit, unialtsuit};
  const int *mix1[] = {jistbl_mix1, unitbl_mix1};
  const int *mix2[] = {jistbl_mix2, unitbl_mix2};


  /* options */

  for (opt = 1; argc > opt && argv[opt][0] == '-'; opt++) {
    if (strcmp(argv[opt], "-ascii") == 0) {
      ascii = 1;
    } else {
      printf("usage: bdf2cgrom66 [-ascii] fontfile1.bdf [fontfile2.bdf]\n");
      exit(1);
    }
  }

  if (argc < opt + 1) {
    printf("usage: bdf2cgrom66 [-ascii] fontfile1.bdf [fontfile2.bdf]\n");
    exit(1);
  }

  if (strcmp(argv[opt], "-") == 0) {
    fp1 = stdin;
  } else {
    fp1 = fopen(argv[opt], "rb");
    if (fp1 == NULL) {
      printf("cannot open %s\n", argv[opt]);
      exit(1);
    }
  }

  if (argc < opt + 2) {
    fp2 = fp1;
  } else if (strcmp(argv[opt + 1], "-") == 0) {
    fp2 = stdin;
  } else {
    fp2 = fopen(argv[opt + 1], "rb");
    if (fp2 == NULL) {
      printf("cannot open %s\n", argv[opt + 1]);
      exit(1);
    }
  }


  /* CGROM60.66 */

  memset(bmp60, 0x00, sizeof(bmp60));
  cnv(fp1, ascii, tbl, altsuit, NULL, NULL, SIZEX, SIZEY_60, bmp60);

  /* block character */
  for (i = 0; i < 0x40; i++) {
    for (j = 0; j < 12; j++) {
      bmp60[NCHR + i][j] = ((i & (0x20 >> (j / 4 * 2))) ? 0xf0 : 0)
	| ((i & (0x10 >> (j / 4 * 2))) ? 0x0f : 0);
    }
  }

  /* output */
  strncpy(outfile, "CGROM60.66", sizeof(outfile));
  fpout = fopen(outfile, "wb");
  if (fpout == NULL) {
    printf("cannot open %s\n", argv[opt + 1]);
    exit(1);
  }
  for (i = 0; i < NCHR * 2; i++) {
    for (j = 0; j < 16; j++) {
      fputc(bmp60[i][j], fpout);
    }
  }
  fclose(fpout);


  /* CGROM66.66 */

  memset(bmp60, 0x00, sizeof(bmp60));
  rewind(fp2);
  cnv(fp2, ascii, tbl, altsuit, NULL, NULL, SIZEX, SIZEY_66, bmp60);
  rewind(fp2);
  cnv(fp2, 0, tbl_semi, NULL, mix1, mix2, SIZEX, SIZEY_66, &bmp60[NCHR]);

  for (i = 0x19; i < 0x20; i++) {
    bmp60[NCHR + i][0] = 0xfe;
    for (j = 0; j < i - 0x19; j++) {
      bmp60[NCHR + i][0] = (bmp60[NCHR + i][0] << 1) & 0xff;
    }
    memset(&bmp60[NCHR + i][1], bmp60[NCHR + i][0], 9);
  }

  bmp60[NCHR + 0x20][0] = 0x01;
  bmp60[NCHR + 0x21][0] = 0x80;
  bmp60[NCHR + 0x22][0] = 0xff;
  bmp60[NCHR + 0x23][0] = 0xff;
  for (i = 0x20; i < 0x24; i++) {
    unsigned char c = 0;
    if (i == 0x20) {
      c = 0x01;
    }
    if (i == 0x21) {
      c = 0x80;
    }
    for (j = 1; j < 10; j++) {
      if ((i < 0x22 && j % 5 == 1) ||
	  (i > 0x21 && j % 5 == 4)) {
	bmp60[NCHR + i][j] = bmp60[NCHR + i][j - 1];
	continue;
      }
      if (i == 0x20 || i == 0x23) {
	bmp60[NCHR + i][j] = (bmp60[NCHR + i][j - 1] << 1) + c;
      } else {
	bmp60[NCHR + i][j] = (bmp60[NCHR + i][j - 1] >> 1) + c;
      }
    }
  }

  bmp60[NCHR + 0x24][0] = 0xcc;
  bmp60[NCHR + 0x25][0] = 0xaa;
  for (i = 0x24; i < 0x26; i++) {
    for (j = 1; j < 10; j++) {
      if (i == 0x24 && j % 2 == 1) {
	bmp60[NCHR + i][j] = bmp60[NCHR + i][j - 1];
      } else {
	bmp60[NCHR + i][j] = bmp60[NCHR + i][j - 1] ^ 0xff;
      }
    }
  }

  fclose(fp2);

  /* block character */
  for (i = 0; i < 0x10; i++) {
    for (j = 0; j < 10; j++) {
      if (j < 5) {
	if (i & 0x08) {
	  bmp60[NCHR + i][j] += 0xf0;
	}
	if (i & 0x04) {
	  bmp60[NCHR + i][j] += 0x0f;
	}
      } else {
	if (i & 0x02) {
	  bmp60[NCHR + i][j] += 0xf0;
	}
	if (i & 0x01) {
	  bmp60[NCHR + i][j] += 0x0f;
	}
      }
    }
  }

  for (i = 0x10; i < 0x19; i++) {
    for (j = 0; j < 10; j++) {
      if (j + i > 0x18) {
	bmp60[NCHR + i][j] = 0xff;
      }
    }
  }

  for (i = 0x19; i < 0x20; i++) {
    bmp60[NCHR + i][0] = 0xfe;
    for (j = 0; j < i - 0x19; j++) {
      bmp60[NCHR + i][0] = (bmp60[NCHR + i][0] << 1) & 0xff;
    }
    memset(&bmp60[NCHR + i][1], bmp60[NCHR + i][0], 9);
  }

  bmp60[NCHR + 0x20][0] = 0x01;
  bmp60[NCHR + 0x21][0] = 0x80;
  bmp60[NCHR + 0x22][0] = 0xff;
  bmp60[NCHR + 0x23][0] = 0xff;
  for (i = 0x20; i < 0x24; i++) {
    unsigned char c = 0;
    if (i == 0x20) {
      c = 0x01;
    }
    if (i == 0x21) {
      c = 0x80;
    }
    for (j = 1; j < 10; j++) {
      if ((i < 0x22 && j % 5 == 1) ||
	  (i > 0x21 && j % 5 == 4)) {
	bmp60[NCHR + i][j] = bmp60[NCHR + i][j - 1];
	continue;
      }
      if (i == 0x20 || i == 0x23) {
	bmp60[NCHR + i][j] = (bmp60[NCHR + i][j - 1] << 1) + c;
      } else {
	bmp60[NCHR + i][j] = (bmp60[NCHR + i][j - 1] >> 1) + c;
      }
    }
  }

  bmp60[NCHR + 0x24][0] = 0xcc;
  bmp60[NCHR + 0x25][0] = 0xaa;
  for (i = 0x24; i < 0x26; i++) {
    for (j = 1; j < 10; j++) {
      if (i == 0x24 && j % 2 == 1) {
	bmp60[NCHR + i][j] = bmp60[NCHR + i][j - 1];
      } else {
	bmp60[NCHR + i][j] = bmp60[NCHR + i][j - 1] ^ 0xff;
      }
    }
  }

  /* no data */
  for (i = NCHR + 1; i < NCHR * 2; i++) {
    if (isnodata(bmp60[i])) {
      for (j = 0; j < SIZEY_66 - 1; j++) {
	bmp60[i][j] = (1 << SIZEX) - 2;
      }
      bmp60[i][SIZEY_66 / 2 - 1] = 0;
    }
  }

  /* output */
  strncpy(outfile, "CGROM66.66", sizeof(outfile));
  fpout = fopen(outfile, "wb");
  if (fpout == NULL) {
    printf("cannot open %s\n", argv[opt + 1]);
    exit(1);
  }
  for (i = 0; i < NCHR * 2; i++) {
    for (j = 0; j < 16; j++) {
      fputc(bmp60[i][j], fpout);
    }
  }
  fclose(fpout);

  return 0;
}


void cnv(FILE *fp, int ascii, const int **tbl, const int **altsuit, const int **mix1, const int **mix2, int size_x_out, int size_y_out, unsigned char bmp60[][16])
{
  int i, j;
  int code, chr;
  int count;
  int charset;
  int size_x, size_y;
  int offset_x, offset_y;
  int pixel_x, pixel_y;
  int ascent, descent;
  int x, y;
  int mix;
  long long data;
  double ratio_x, ratio_y;
  int done[NCHR] = {0}, mixdone1[NCHR] = {0}, mixdone2[NCHR] = {0};
  char line[100];
  unsigned char bmpbdf[BDFSIZE][BDFSIZE];
  long fpos;

  int mixchr[] = {
    /* left-right */
    0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x78, 0x77,
    0x3a, 0x3b, 0x3c,
    0x46, 0x63,
    /* down-up */
    0x7c, 0x7d, 0x7e, 0x7f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 0x49,
    0x83,
    /* square */
    0x97, 0x98, 0x99, 0xb9,
    /* circle */
    0xa4, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    0xb4, 0xb8,
    /* other */
    0x5e, 0x61, 0x6e, 0x6f, 0x95, 0x96, 0x9b, 0xbf,
  };
  const double mixpar[][8] = {
    /* left-right */
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {1.5, 0, 1, 0,  3, 2, 1, 0},
    {2, 0, 1, 0,  2, 1, 1, 0},
    {2, 0, 1, 0,  2, 1, 1, 0},
    {2, 0, 1, 0,  2, 1, 1, 0},
    {2, 0, 1, 0,  2, 0.75, 1, 0},
    {2, 0, 1, 0,  2, 0.75, 1, 0},
    /* down-up */
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1, 0,  1, 0, 2, 0},
    {1, 0, 1.5, -0.4,  1, 0, 2, 0},
    /* square */
    {1, 0, 1, 0,  2, 0.5, 2, -0.5},
    {1, 0, 1, 0,  2, 0.5, 2, -0.5},
    {1, 0, 1, 0,  1, 0, 1, 0},
    {1, 0, 1, 0,  2, 0.5, 2, -0.5},
    /* circle */
    {1, 0, 1, 0,  3, 1, 3, -1},
    {1, 0, 1, 0,  3, 1, 3, -1},
    {1, 0, 1, 0,  3, 1, 3, -1},
    {1, 0, 1, 0,  4, 1.5, 1.5, -0.25},
    {1, 0, 1, 0,  1.6, 0.3, 2, -0.5},
    {1, 0, 1, 0,  3, 1, 3, -1},
    {1, 0, 1, 0,  3, 1, 3, -1},
    {1, 0, 1, 0,  1.5, 0.25, 1.5, -0.25},
    {1, 0, 1, 0,  1.5, 0.25, 1.5, -0.25},
    {1, 0, 1, 0,  2, 0.5, 1.5, -0.25},
    {1, 0, 1, 0,  3, 1, 3, -1},
    {1, 0, 1, 0,  2, 0.5, 1.5, -0.25},
    {1, 0, 1, 0,  2, 0.5, 1.5, -0.25},
    /* other */
    {1, 0, 1, 0,  1, 0, 1, 0},
    {1.33, 0.167, 1.33, -0.167,  1, 0, 1, 0},
    {1, 0, 1, 0,  1, 0, 1, 0},
    {1, 0, 1, 0,  1, 0, 1, 0},
    {2, 0.5, 2, -0.5,  2, 0.5, 2, -0.5},
    {2, 0.5, 2, -0.5,  2, 0.5, 2, -0.5},
    {1, 0, 1, 0,  1, 0, 1, 0},
    {1, 0, 1, 0,  1, 0, 1, 0},
  };

  charset = getbdfpar(fp, ascii, &pixel_x, &ascent, &descent);
  pixel_y = ascent + descent;

  count = 0;
  while (count < NCHR + 4) {
    fpos = ftell(fp);
    if (fgets(line, sizeof(line), fp) == NULL) {
      break;
    }
    chr = -1;
    if (sscanf(line, "ENCODING %d", &code) == 1) {
      for (i = 0; i < NCHR; i++) {
	if (code && !done[i] && ((ascii && code == i) || (!ascii && code == tbl[charset][i]))) {
	  chr = i;
	  done[chr] = 1;
	  count++;
	  if (!isnodata(bmp60[chr])) {
	    memset(bmp60[chr], 0, size_y_out);
	  }
	  break;
	}
      }

      /* suits */
      for (i = 0; i < 4; i++) {
	if (chr == -1 && !ascii && altsuit && code == altsuit[charset][i]) {
	  chr = 0x80 + i;
	  if (isnodata(bmp60[chr])) {
	    count++;
	  } else {
	    chr = -1;
	  }
	  break;
	}
      }

      /* mixed character */
      mix = 0;
      if (chr == -1 && mix1 && mix2) {
	for (i = 0; i < sizeof(mixchr) / sizeof(mixchr[0]); i++) {
	  if (!done[mixchr[i]] &&
	      ((!mixdone1[i] && code == mix1[charset][i]) ||
	       (!mixdone2[i] && code == mix2[charset][i]))) {
	    chr = mixchr[i];
	    mix = 1;
	    break;
	  }
	}
      }

    }

    if (chr != -1) {
      memset(bmpbdf, 0x00, sizeof(bmpbdf));
      do {
	if (fgets(line, sizeof(line), fp) == NULL) {
	  break;
	}
      } while (sscanf(line, "BBX %d %d %d %d", &size_x, &size_y, &offset_x, &offset_y) != 4);

      if (pixel_x > size_x_out) {
	ratio_x = (double)pixel_x / size_x_out;
      } else {
	ratio_x = 1;
	offset_x += (size_x_out - pixel_x) / 2;
      }
      if (pixel_y > size_y_out) {
	ratio_y = (double)pixel_y / size_y_out;
      } else {
	ratio_y = 1;
	offset_y -= (size_y_out - pixel_y) / 2;
      }

      if (offset_x < 0) {
	offset_x = 0;
      }

      /* mixed character */
      if (mix) {
	for (i = 0; i < sizeof(mixchr) / sizeof(mixchr[0]); i++) {
	  if (!mixdone1[i] && code == mix1[charset][i]) {
	    mixdone1[i] = 1;
	    ratio_x *= mixpar[i][0];
	    offset_x += pixel_x * mixpar[i][1];
	    ratio_y *= mixpar[i][2];
	    offset_y += pixel_y * mixpar[i][3];
	    break;
	  } else if (!mixdone2[i] && code == mix2[charset][i]) {
	    mixdone2[i] = 1;
	    ratio_x *= mixpar[i][4];
	    offset_x += pixel_x * mixpar[i][5];
	    ratio_y *= mixpar[i][6];
	    offset_y += pixel_y * mixpar[i][7];
	    break;
	  }
	}
      }

      do {
	if (fgets(line, sizeof(line), fp) == NULL) {
	  break;
	}
      } while (strncmp(line, "BITMAP", 6) != 0);

      for (i = 0; i < size_y; i++) {
	fgets(line, sizeof(line), fp);
#ifdef WIN32
	while (sscanf(line, "%I64x", &data) != 1) ;
#else
	while (sscanf(line, "%llx", &data) != 1) ;
#endif
	for (j = 0; j < size_x; j++) {
	  x = j + offset_x;
	  y = i + ascent - size_y - offset_y;
	  if (0 <= x && x <= BDFSIZE && 0 <= y && y <= BDFSIZE) {
	    bmpbdf[x][y] = (data >> ((BDFSIZE - size_x) % 8 + size_x - j - 1)) & 1;
	  }
	}
      }

      if (size_y > 0) {
	for (i = 0; i < size_y_out; i++) {
	  //	  bmp60[chr][i] = 0;
	  for (j = 0; j < size_x_out; j++) {
	    data = 0;
	    for (x = j * ratio_x; x < (int)((j + 1) * ratio_x + .01) && x < BDFSIZE; x++) {
	      for (y = i * ratio_y; y < (int)((i + 1) * ratio_y + .01) && y < BDFSIZE; y++) {
		data += bmpbdf[x][y];
	      }
	    }
	    if ((double)data / (x - (int)(j * ratio_x)) * (y - (int)(i * ratio_y)) > 0) {
	      bmp60[chr][i] |= 1 << (size_x_out - j - 1);
	    }
	  }
	}
      }
      fseek(fp, fpos, SEEK_SET);
    }
  }

  if (mix1 && mix2) {
    for (i = 0; i < sizeof(mixchr) / sizeof(mixchr[0]); i++) {
      if (!done[mixchr[i]] && (!mixdone1[i] || !mixdone2[i])) {
	memset(bmp60[mixchr[i]], 0, size_y_out);
      }
    }
  }
}


int getbdfpar(FILE *fp, int ascii, int *pixel_x, int *ascent, int *descent)
{
  int code = 0;
  int x1, x2;
  int xmin = 999, xmax = -1;
  int dummy;
  int result = JIS;
  char line[100] = "";
  char charset[100] = "";

  *ascent = -1;
  *descent = -1;

  while (fgets(line, sizeof(line), fp)) {
    sscanf(line, "ENCODING %d", &code);
    x1 = x2 = 0;
    if (sscanf(line, "BBX %d %d %d %d", &x1, &dummy, &x2, &dummy)) {
      if (result != UNI || (code != 0x2e3a && code != 0x2e3b)) {
	if (x1 < xmin) xmin = x1;
	if (x2 < xmin) xmin = x2;
	if (x1 > xmax) xmax = x1;
	if (x2 > xmax) xmax = x2;
      }
    }
    sscanf(line, "FONT_ASCENT %d", ascent);
    sscanf(line, "FONT_DESCENT %d", descent);
    if (sscanf(line, "CHARSET_REGISTRY %s", charset) == 1) {
      if (strncasecmp(charset, "\"JISX0208", 9) == 0 ||
	  strncasecmp(charset, "\"JISX0213", 9) == 0) {
	result = JIS;
      } else if (strcasecmp(charset, "\"ISO10646\"") == 0) {
	result = UNI;
      } else if (!ascii) {
	printf("cannot convert for charset %s\n", charset);
	exit(1);
      }
    }
  }
  *pixel_x = xmax - xmin;
  if (*ascent < 0 || *descent < 0 || *pixel_x < 0 || strlen(charset) == 0) {
    printf("illegal bdf\n");
    exit(1);
  }
  rewind(fp);

  return result;
}


int isnodata(unsigned char *bmp60)
{
  int i;
  unsigned char data = 0;
  for (i = 0; i < 16; i++) {
    data |= bmp60[i];
  }
  return !data;
}
